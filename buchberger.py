import polynomial as poly
import reduction as rd
import numpy as np
import math
import random

def buchberger_random(F):
    """
    The classic buchberger algorithm using random selection.
    @param F: a list of polynomials.
    @return: The Gröbner basis of the ideal generated by F represented as a list of polynomials.
    """

    assert all([isinstance(f, poly.Polynomial) for f in F]), 'The input must be a list of polynomials.'

    G = F
    P = set([frozenset([F[i], F[j]]) for i in range(len(F)) for j in range(i + 1, len(F))])
    counter = 1
    print('------------------')
    while len(P) > 0:
        fg = random.sample(P, 1)[0]
        f, g = tuple(fg)
        print('Iteration {}:'.format(counter))
        print('The choice of pair is {} and {}'.format(f, g))
        P.remove(fg)
        r = rd.reduce_lst(rd.S(f, g), G)
        print('r is {}'.format(r))
        if not r.is_zero():
            P = P.union([frozenset([f, r]) for f in G])
            G = list(set(G).union([r]))
        counter += 1
        print('------------------')
    return G


def remove_duplicate(lst):
    """
    Remove duplicates in a list and preserve order.
    @param lst: The list from which to remove duplicates.
    @return: A list with duplicates removed and order preserved.
    """

    seen = set()
    seen_add = seen.add
    return [x for x in lst if not (x in seen or seen_add(x))]


def buchberger_first(F):
    """
    The classic buchberger algorithm using first selection.
    @param F: a list of polynomials.
    @return: The Gröbner basis of the ideal generated by F represented as a list of polynomials.
    """

    assert all([isinstance(f, poly.Polynomial) for f in F]), 'The input must be a list of polynomials.'

    G = F
    P = [frozenset([F[i], F[j]]) for i in range(len(F)) for j in range(i + 1, len(F))]
    P = remove_duplicate(P)
    counter = 1
    print('------------------')
    while len(P) > 0:
        fg = P.pop(0)
        f, g = tuple(fg)
        print('Iteration {}:'.format(counter))
        print('The choice of pair is {} and {}'.format(f, g))
        r = rd.reduce_lst(rd.S(f, g), G)
        print('r is {}'.format(r))
        if not r.is_zero():
            for f in G:
                P.append(frozenset([f, r]))
            P = remove_duplicate(P)
            G = list(set(G).union([r]))
        counter += 1
        print('------------------')

    return G


def buchberger_degree(F):
    """
    The classic buchberger algorithm using degree selection.
    @param F: a list of polynomials.
    @return: The Gröbner basis of the ideal generated by F represented as a list of polynomials.
    """

    assert all([isinstance(f, poly.Polynomial) for f in F]), 'The input must be a list of polynomials.'

    G = F
    P = [frozenset([F[i], F[j]]) for i in range(len(F)) for j in range(i + 1, len(F))]
    P = remove_duplicate(P)
    total_degree = [(list(x)[0].lt().lcm(list(x)[1].lt())).degree for x in P]
    counter = 1
    print('------------------')
    while len(P) > 0:
        min_degree = min(total_degree)
        min_index = total_degree.index(min_degree)
        fg = P[min_index]
        P.remove(fg)
        total_degree.remove(min_degree)
        f, g = tuple(fg)
        print('Iteration {}:'.format(counter))
        print('The choice of pair is {} and {}'.format(f, g))
        r = rd.reduce_lst(rd.S(f, g), G)
        print('r is {}'.format(r))
        if not r.is_zero():
            for f in G:
                P.append(frozenset([f, r]))
            P = remove_duplicate(P)
            G = list(set(G).union([r]))
            total_degree = [(list(x)[0].lt().lcm(list(x)[1].lt())).degree for x in P]
        counter += 1
        print('------------------')

    return G
